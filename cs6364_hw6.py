# -*- coding: utf-8 -*-
"""CS6364_HW6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15IF-eTiJVQIYjCRO6oQN1UxVddJz69_0
"""

# torch
import torch
import torch.nn    as nn
import torch.optim as optim

# torch utils
import torchvision
import torchvision.transforms as transforms

# additional libraries
import math
import numpy             as np
import pandas as pd
import matplotlib.pyplot as plt
from typing import List, Text
# %matplotlib inline

from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, classification_report, accuracy_score

# version check
# print(torch.__version__)

device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

boston_data: pd.DataFrame = pd.read_csv('boston.csv')
input_attributes: List[Text] = ['LSTAT','RM','MEDV']
boston_data = boston_data[input_attributes].dropna()

Binput_data = boston_data.drop('MEDV', axis=1).to_numpy()
Boutput_data = boston_data['MEDV'].to_numpy()

BX_train, BX_test, BY_train, BY_test = train_test_split(Binput_data, Boutput_data, test_size = 0.3)

titanic_data: pd.DataFrame = pd.read_csv('titanic.csv')
titanic_data.loc[titanic_data.sex == 'male', 'sex'] = 0
titanic_data.loc[titanic_data.sex == 'female', 'sex'] = 1

remove_attributes: List[Text] = ['name', 'sibsp', 'parch', 'ticket', 'boat', 'body', 'cabin', 'embarked', 'home.dest']
titanic_data = titanic_data.drop(remove_attributes,axis=1).dropna()

Tinput_data = titanic_data.drop('survived', axis=1).to_numpy()
Toutput_data = titanic_data['survived'].to_numpy()

TX_train, TX_test, TY_train, TY_test = train_test_split(Tinput_data, Toutput_data, test_size = 0.2)

def rmse(Y, predicted_Y):
    return np.sqrt(mean_squared_error(Y,predicted_Y))

print(BX_train.shape)
print(BX_test.shape)
print(BY_train.shape)
print(BY_test.shape)
print(TX_train.shape)
print(TX_test.shape)
print(TY_train.shape)
print(TY_test.shape)

BX_train = torch.from_numpy(BX_train).float()
BX_test = torch.from_numpy(BX_test).float()
BY_train = torch.from_numpy(BY_train).float()
BY_test = torch.from_numpy(BY_test).float()

TX_train = torch.from_numpy(TX_train.astype(float)).float()
TX_test = torch.from_numpy(TX_test.astype(float)).float()
TY_train = torch.from_numpy(TY_train.astype(float)).float()
TY_test = torch.from_numpy(TY_test.astype(float)).float()

class NeuralNet(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(NeuralNet, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size) 
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, num_classes)
        self.tanh = nn.Tanh()
        self.fc3 = nn.Linear(num_classes,1)
    
    def forward(self, x):
        out = self.fc1(x)
        out = self.relu(out)
        out = self.fc2(out)
        out = self.tanh(out)
        out = self.fc3(out)
        return out

model = NeuralNet(2, 16, 32)
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)

total_step = len(BX_train)
num_epochs = 30
for epoch in range(num_epochs):
    for i, data in enumerate(BX_train):  
        # Forward pass
        model.train()
        output = model(data)
        loss = criterion(output, BY_train[i])
        
        # Backward and optimize
        optimizer.zero_grad()
        loss.backward(retain_graph=True)
        optimizer.step()
        
        if (i+1) % 100 == 0:
            print ('Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}' 
                   .format(epoch+1, num_epochs, i+1, total_step, loss.item()))
            
for epoch in range(num_epochs):
    model.eval()
    with torch.no_grad():
        bosttest = model(BX_test)

bosttrain = [0] * len(BX_train)
for i, data in enumerate(BX_train): 
  bosttrain[i] = model(data)

print()
print("The model performance for training set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse(BY_train,bosttrain)))
print()
print("The model performance for testing set")
print("--------------------------------------")
print('RMSE is {}'.format(rmse(BY_test,bosttest)))
print()

class ClassNeuralNet(nn.Module):
    def __init__(self, input_size, hidden_size, num_classes):
        super(ClassNeuralNet, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size) 
        self.relu = nn.ReLU()
        self.fc2 = nn.Linear(hidden_size, num_classes)
        self.tanh = nn.Tanh()
        self.fc3 = nn.Linear(num_classes,1)
        self.sig = nn.Sigmoid()
    
    def forward(self, x):
        out = self.fc1(x)
        out = self.relu(out)
        out = self.fc2(out)
        out = self.tanh(out)
        out = self.fc3(out)
        out = self.sig(out)
        return out

model = ClassNeuralNet(4, 5, 3)
criterion = nn.BCELoss()
optimizer = optim.Adam(model.parameters(), lr=0.01)

total_step = len(TX_train)
num_epochs = 30
for epoch in range(num_epochs):
    for i, data in enumerate(TX_train):  
        # Forward pass
        model.train()
        # print(data)
        output = model(data)
        # print(output)
        # print(TY_train[i])
        loss = criterion(output, TY_train[i])
        
        # Backward and optimize
        optimizer.zero_grad()
        loss.backward(retain_graph=True)
        optimizer.step()
        
        if (i+1) % 100 == 0:
            print ('Epoch [{}/{}], Step [{}/{}], Loss: {:.4f}' 
                   .format(epoch+1, num_epochs, i+1, total_step, loss.item()))
            
for epoch in range(num_epochs):
    model.eval()
    with torch.no_grad():
        Ttest = torch.round(model(TX_test))

# Ttrain = [0] * len(TX_train)
# for i, data in enumerate(TX_train): 
Ttrain = torch.round(model(TX_train))

print()
print("The model performance for training set")
print("--------------------------------------")
print(classification_report(TY_train,Ttrain.detach().numpy()))
print("Accuracy:", accuracy_score(TY_train, Ttrain.detach().numpy()))
print()
print("The model performance for testing set")
print("--------------------------------------")
print(classification_report(TY_test,Ttest.detach().numpy()))
print("Accuracy:", accuracy_score(TY_test, Ttest.detach().numpy()))
print()